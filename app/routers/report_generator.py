from fastapi import APIRouter, HTTPException, BackgroundTasks
from fastapi.responses import FileResponse
from typing import List
import uuid
import os
from datetime import datetime

# Use relative imports that work with your structure
from ..models.report_model import ReportRequest, ReportResponse, ReportType, ReportFormat
from ..services.pdf_service import PDFReportService

# Create a simple HTML service inline to avoid import issues
class SimpleHTMLTemplateService:
    """Simple HTML report generator to avoid import issues"""
    
    def generate_html_report(self, report_data: dict) -> str:
        """Generate simple HTML report"""
        return f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>{report_data['title']}</title>
            <style>
                body {{ font-family: Arial; margin: 40px; }}
                .header {{ background: #2E86AB; color: white; padding: 20px; }}
                .section {{ margin: 20px 0; padding: 15px; background: #f5f5f5; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>{report_data['school_info']['school_name']}</h1>
                <h2>{report_data['title']}</h2>
            </div>
            <div class="section">
                <h3>Executive Summary</h3>
                <p>Report ID: {report_data['report_id']}</p>
                <p>Generated: {report_data['generated_at']}</p>
                <p>Overall Risk: <strong>{report_data.get('overall_risk', 'Unknown')}</strong></p>
            </div>
            <div class="section">
                <h3>Incident Details</h3>
                <p>Found {len(report_data.get('ioc_findings', []))} threat indicators and 
                {len(report_data.get('log_findings', []))} security events.</p>
            </div>
            <div class="section">
                <h3>Recommended Actions</h3>
                <ul>
                    {"".join([f"<li>{action}</li>" for action in report_data.get('recommended_actions', [])])}
                </ul>
            </div>
            <footer>
                <p>Generated by ThreatIntellAI - School Cybersecurity Platform</p>
            </footer>
        </body>
        </html>
        """

router = APIRouter()

# Initialize services
pdf_service = PDFReportService()
html_service = SimpleHTMLTemplateService()  # Use simple version

# Report storage directory
REPORT_STORAGE_DIR = "app/storage/generated_reports"

def ensure_report_directory():
    """Ensure report storage directory exists"""
    os.makedirs(REPORT_STORAGE_DIR, exist_ok=True)

@router.post("/generate", response_model=ReportResponse)
async def generate_report(report_request: ReportRequest):
    """
    Generate comprehensive incident report in PDF/HTML format
    """
    try:
        ensure_report_directory()
        
        # Generate unique report ID
        report_id = f"report_{uuid.uuid4().hex[:8]}"
        generated_at = datetime.now().isoformat()
        
        # Prepare report data
        report_data = await _prepare_report_data(report_request, report_id, generated_at)
        
        # Determine output format and generate files
        download_urls = []
        file_paths = []
        
        if report_request.format in [ReportFormat.PDF, ReportFormat.BOTH]:
            pdf_path = await _generate_pdf_report(report_data, report_id)
            file_paths.append(pdf_path)
            download_urls.append(f"/api/v1/report/download/{report_id}?format=pdf")
        
        if report_request.format in [ReportFormat.HTML, ReportFormat.BOTH]:
            html_path = await _generate_html_report(report_data, report_id)
            file_paths.append(html_path)
            download_urls.append(f"/api/v1/report/download/{report_id}?format=html")
        
        # For simplicity, return the first download URL
        primary_download_url = download_urls[0] if download_urls else ""
        primary_file_path = file_paths[0] if file_paths else ""
        
        # Get file size
        file_size = os.path.getsize(primary_file_path) if primary_file_path and os.path.exists(primary_file_path) else 0
        
        return ReportResponse(
            report_id=report_id,
            report_type=report_request.report_type,
            format=report_request.format,
            title=report_request.title,
            download_url=primary_download_url,
            file_path=primary_file_path,
            file_size=file_size,
            generated_at=generated_at,
            school_name=report_request.school_info.school_name
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Report generation failed: {str(e)}")

@router.get("/download/{report_id}")
async def download_report(report_id: str, format: str = "pdf"):
    """
    Download generated report file
    """
    try:
        ensure_report_directory()
        
        if format == "pdf":
            filename = f"{report_id}.pdf"
            media_type = "application/pdf"
        elif format == "html":
            filename = f"{report_id}.html"
            media_type = "text/html"
        else:
            raise HTTPException(status_code=400, detail="Invalid format. Use 'pdf' or 'html'")
        
        file_path = os.path.join(REPORT_STORAGE_DIR, filename)
        
        if not os.path.exists(file_path):
            raise HTTPException(status_code=404, detail="Report not found")
        
        return FileResponse(
            path=file_path,
            filename=filename,
            media_type=media_type
        )
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Download failed: {str(e)}")

@router.get("/test")
async def test_report_endpoint():
    """Test if reports endpoint is working"""
    return {
        "message": "✅ Reports endpoint is working!",
        "endpoints": {
            "generate_report": "POST /api/v1/report/generate",
            "download_report": "GET /api/v1/report/download/{report_id}",
            "school_templates": "GET /api/v1/report/templates/schools"
        }
    }

@router.get("/templates/schools")
async def get_school_templates():
    """
    Get sample school templates for report generation
    """
    return {
        "sample_schools": [
            {
                "school_name": "Springfield Elementary School",
                "district": "Springfield School District",
                "contact_person": "Principal Skinner",
                "contact_email": "principal@springfield-es.edu",
                "phone": "(555) 123-4567"
            },
            {
                "school_name": "Shelbyville High School", 
                "district": "Shelbyville District",
                "contact_person": "Superintendent Chalmers",
                "contact_email": "superintendent@shelbyville-hs.edu",
                "phone": "(555) 987-6543"
            }
        ],
        "sample_students": [
            {
                "student_name": "Bart Simpson",
                "grade_level": "4th Grade",
                "teacher_name": "Mrs. Krabappel",
                "incident_location": "Computer Lab"
            },
            {
                "student_name": "Lisa Simpson",
                "grade_level": "2nd Grade", 
                "teacher_name": "Miss Hoover",
                "incident_location": "Library"
            }
        ]
    }

async def _prepare_report_data(report_request: ReportRequest, report_id: str, generated_at: str) -> dict:
    """Prepare comprehensive report data from request"""
    
    # Mock data for demonstration
    ioc_findings = [
        {
            "ioc": "192.168.1.100",
            "ioc_type": "ip",
            "risk_level": "malicious",
            "threat_labels": ["phishing", "c2"],
            "confidence_score": 0.76
        },
        {
            "ioc": "http://malicious-site.com",
            "ioc_type": "url", 
            "risk_level": "suspicious",
            "threat_labels": ["phishing"],
            "confidence_score": 0.45
        }
    ]
    
    log_findings = [
        {
            "pattern_name": "Brute Force Attack",
            "description": "Multiple failed login attempts from IP 192.168.1.100 (5 attempts)",
            "threat_severity": "high",
            "occurrences": 5
        },
        {
            "pattern_name": "Unknown User Attempts", 
            "description": "Login attempts with 2 unknown usernames",
            "threat_severity": "medium",
            "occurrences": 2
        }
    ]
    
    # AI explanation
    ai_explanation = """
Security Analysis - School Network Incident

OVERALL RISK: HIGH

What we found in your school's logs:
• Brute Force Attack: Multiple failed login attempts from suspicious IP addresses
• Unknown User Attempts: Login attempts with unfamiliar usernames

What this means for your school:
These patterns indicate targeted attempts to access school systems. Immediate action is recommended to prevent potential security breaches.

Simple explanation:
Someone is trying to break into school computer systems using automated tools.
"""
    
    # Recommended actions
    recommended_actions = [
        "Block the suspicious IP addresses in school firewall",
        "Reset passwords for affected user accounts", 
        "Enable multi-factor authentication for admin accounts",
        "Conduct security awareness training for staff",
        "Monitor network logs for similar activity",
        "Update all school software with latest security patches"
    ]
    
    # Calculate overall risk
    overall_risk = _calculate_overall_risk(ioc_findings, log_findings)
    
    return {
        "report_id": report_id,
        "title": report_request.title,
        "report_type": report_request.report_type,
        "school_info": report_request.school_info.dict(),
        "student_info": report_request.student_info.dict() if report_request.student_info else {},
        "ioc_findings": ioc_findings,
        "log_findings": log_findings,
        "ai_explanation": ai_explanation,
        "recommended_actions": recommended_actions,
        "overall_risk": overall_risk,
        "generated_at": generated_at
    }

async def _generate_pdf_report(report_data: dict, report_id: str) -> str:
    """Generate PDF report"""
    pdf_filename = f"{report_id}.pdf"
    pdf_path = os.path.join(REPORT_STORAGE_DIR, pdf_filename)
    
    pdf_service.generate_incident_report(report_data, pdf_path)
    return pdf_path

async def _generate_html_report(report_data: dict, report_id: str) -> str:
    """Generate HTML report"""
    html_filename = f"{report_id}.html"
    html_path = os.path.join(REPORT_STORAGE_DIR, html_filename)
    
    html_content = html_service.generate_html_report(report_data)
    
    with open(html_path, 'w', encoding='utf-8') as f:
        f.write(html_content)
    
    return html_path

def _calculate_overall_risk(ioc_findings: List[dict], log_findings: List[dict]) -> str:
    """Calculate overall risk level based on findings"""
    risk_scores = {
        'critical': 4,
        'high': 3, 
        'malicious': 3,
        'medium': 2,
        'suspicious': 2,
        'low': 1,
        'safe': 0
    }
    
    max_score = 0
    for finding in ioc_findings + log_findings:
        risk_level = finding.get('risk_level') or finding.get('threat_severity', 'low')
        score = risk_scores.get(risk_level.lower(), 0)
        max_score = max(max_score, score)
    
    if max_score >= 3:
        return 'high'
    elif max_score >= 2:
        return 'medium'
    else:
        return 'low'